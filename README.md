# Java_Block_Chain

## 简介

* 详细介绍：https://blog.zrcode.top/index.php/archives/307/

## 实现的功能

* 多线程实现包含多节点的区块链网络
* 客户端可向区块链网络提交交易
* 区块链节点含有交易池，打包区块时从交易池中提取交易。
* 客户端使用ECDSA算法对交易进行签名，并用JSON序列化交易
* 交易池可维护节点内未加入区块链的交易
* 使用POW工作量证明生成区块，并在区块链网络中进行共识
* 使用最长链原则作为区块链分叉的解决方案
* 存储模块打印落盘日志
* 执行模块仅模拟执行交易，并不具备实际意义
* 存储模块仅在内存中进行存储，不涉及磁盘存储
* 不包含网络通信

## 实现的数据结构

* Transaction 交易
* Receipt 交易回执
* Transaction Pool 交易池
* Block 区块
  * Block Header 区块头
  * Block Body 区块体，包含交易以及回执信息
* Wallet 节点钱包，存储公私钥对

## 代码

### 主要代码流程解释

1. 客户端Client根据创世时间生成一个节点数为4的区块链网络，并取Node 0作为连接的节点。同时每隔5s向区块链网络中提交一个交易（模拟交易，不具备实际意义）。
2. 节点Node构造时，会初始化大小为``poolSize``的交易池，同时将``blockSize``作为交易池的一个参数，表示一个区块包含的交易数量，每次打包区块时会取``blockSize``数量的交易。并新建线程执行``sealer()``函数，该函数将持续监听交易池，进行打包区块、执行、共识等操作。
3. ``sealer()``函数在交易池中交易数量达到``blockSize``时会进行打包区块，在打包前，根据最长链原则，调用``synchronizeChain()``同步区块链网络中的最长链。打包完成后，调用``Execution``模块模拟执行交易，返回交易回执(模拟执行，无实际意义)，跟新区块头信息，调用``mine()``函数进行POW工作量证明。
4. ``mine(String lashHash)``函数则利用Block除了nonce以外的区块值，以及随机的初始nonce值，进行计算，以计算出目标nonce值，使得该区块的hash值前缀0的个数为``difficulty``个。
5. 共识模块则是在某节点计算出相应nonce值时，调用``consensus(Block)``函数广播至区块链网络的其他节点，并由各个节点新建进程进行验证，验证完成后调用``storage()``存储模块进行存储落盘。
6. 存储模块``storage()``，删除交易池中的交易，并再次对区块进行验证，同时落盘存储交易、区块等数据，打印落盘日志。

### 其余代码部分

1. ``synchronizeChain()``用于同步区块链网络中的最长链，解决区块链分叉问题。
2. ``ECDSAUtil``用于生成ECDSA非对称加密算法的公私钥对，以及加签验签函数。
3. ``MerkleUtil``用于对实现Hashable接口的实体列表，生成Merkle Root。同时对于非2的幂次数量的列表，复制最后一个实体直到2的幂次。
4. ``HashUtil``实现Hash计算

## 已知的问题

* 单节点采用最长链原则恢复区块链时，该节点的交易池可能会与其他节点的交易池不一致。
